{
  "data": {
    "content": "## Scenario overview\n\nThis article describes an organization that develops cloud-native applications. Any application needs a compute resource to work on. In the cloud-native world, this compute resource is a Kubernetes cluster. An organization may have a single cluster or, more commonly, multiple clusters. So the organization must decide which applications should work on which clusters. In other words, they must schedule the applications across clusters. The result of this decision, or scheduling, is a model of the desired state of the clusters in their environment. Having that in place, they need somehow to deliver applications to the assigned clusters so that they can turn the desired state into the reality, or, in other words, reconcile it.\n\nEvery application goes through a software development lifecycle that promotes it to the production environment. For example, an application is built, deployed to Dev environment, tested and promoted to Stage environment, tested, and finally delivered to production. For a cloud-native application, the application requires and targets different Kubernetes cluster resources throughout its lifecycle. In addition, applications normally require clusters to provide some platform services, such as Prometheus and Fluentbit, and infrastructure configurations, such as networking policy.\n\nDepending on the application, there may be a great diversity of cluster types to which the application is deployed. The same application with different configurations could be hosted on a managed cluster in the cloud, on a connected cluster in an on-premises environment, on a group of clusters on semi-connected edge devices on factory lines or military drones, and on an air-gapped cluster on a starship. Another complexity is that clusters in early lifecycle stages such as Dev and QA are normally managed by the developer, while reconciliation to actual production clusters may be managed by the organization's customers. In the latter case, the developer may be responsible only for promoting and scheduling the application across different rings.",
    "file_path": "/Users/cloudchase/Desktop/Vibe_Coding/Cursor/ai-content-developer/work/tmp/azure-management-docs/articles/azure-arc/kubernetes/conceptual-workload-management.md",
    "heading_path": [
      "Workload management in a multi-cluster environment with GitOps",
      "Scenario overview"
    ],
    "section_level": 2,
    "chunk_index": 1,
    "frontmatter": {
      "title": "Workload management in a multi-cluster environment with GitOps",
      "description": "This article provides a conceptual overview of the workload management in a multi-cluster environment with GitOps.",
      "ms.date": "03/29/2023",
      "ms.topic": "concept-article",
      "author": "eedorenko",
      "ms.author": "iefedore"
    },
    "embedding_content": "Document: Workload management in a multi-cluster environment with GitOps | Topic: concept-article | Description: This article provides a conceptual overview of the workload management in a multi-cluster environmen | Section: Workload management in a multi-cluster environment with GitOps > Scenario overview | ## Scenario overview\n\nThis article describes an organization that develops cloud-native applications. Any application needs a compute resource to work on. In the cloud-native world, this compute resource is a Kubernetes cluster. An organization may have a single cluster or, more commonly, multiple clusters. So the organization must decide which applications should work on which clusters. In other words, they must schedule the applications across clusters. The result of this decision, or scheduling, is a model of the desired state of the clusters in their environment. Having that in place, they need somehow to deliver applications to the assigned clusters so that they can turn the desired state into the reality, or, in other words, reconcile it.\n\nEvery application goes through a software development lifecycle that promotes it to the production environment. For example, an application is built, deployed to Dev environment, tested and promoted to Stage environment, tested, and finally delivered to production. For a cloud-native application, the application requires and targets different Kubernetes cluster resources throughout its lifecycle. In addition, applications normally require clusters to provide some platform services, such as Prometheus and Fluentbit, and infrastructure configurations, such as networking policy.\n\nDepending on the application, there may be a great diversity of cluster types to which the application is deployed. The same application with different configurations could be hosted on a managed cluster in the cloud, on a connected cluster in an on-premises environment, on a group of clusters on semi-connected edge devices on factory lines or military drones, and on an air-gapped cluster on a starship. Another complexity is that clusters in early lifecycle stages such as Dev and QA are normally managed by the developer, while reconciliation to actual production clusters may be managed by the organization's customers. In the latter case, the developer may be responsible only for promoting and scheduling the application across different rings.",
    "embedding": null,
    "embedding_model": null,
    "embedding_generated_at": null,
    "content_hash": "3bcc71e566ff10e865e36a35d435cd821788ac30ee5a15f71bead56f2670e0f1",
    "file_id": "68b84d3ed0d9d36d4ec56ccb018594e09d36629cea891036b7b04a8fba544e6e",
    "chunk_id": "6c0fbced6bd35699d82d8a7056016ba2ad6fc3637214f42ae256973dc1a4e17f",
    "prev_chunk_id": "9c581bfd9188878d88ffe27a51d719048a134e27e3d59d2c817108c1d03f7589",
    "next_chunk_id": "960fd8c31d37d4a735669b03560f8e94c88341d21d62ccd1ad34e1270c4cf84e",
    "parent_heading_chunk_id": "97ea4eec0eba99bbe5f8c55f9a68f9a985be134e19e49f8f6c97ed9781f79187",
    "total_chunks_in_file": 31
  },
  "meta": {
    "type": "chunk",
    "file": "/Users/cloudchase/Desktop/Vibe_Coding/Cursor/ai-content-developer/work/tmp/azure-management-docs/articles/azure-arc/kubernetes/conceptual-workload-management.md",
    "section": [
      "Workload management in a multi-cluster environment with GitOps",
      "Scenario overview"
    ],
    "has_embedding": false
  },
  "timestamp": "2025-06-02T15:36:19.201784"
}