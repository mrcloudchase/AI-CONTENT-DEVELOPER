{
  "data": {
    "content": "## Example workflow\n\nAs an application developer, Alice:\n\n* Writes application code.\n* Determines how to run the application in a Docker container.\n* Defines the templates that run the container and dependent services in a Kubernetes cluster.\n\nAlice wants to make sure the application has the capability to run in multiple environments, but she doesn't know the specific settings for each environment.\n\nSuppose Alice wants to make an application change that alters the Docker image used in the application deployment template.\n\n1. Alice changes the deployment template, pushes it to a remote branch called `alice` in the Application Repo, and opens a pull request for review against the `main` branch.\n\n1. Alice asks her team to review the change.\n\n   * The PR pipeline runs validation.\n   * After a successful PR pipeline run and team approval, the change is merged.\n\n1. The CI pipeline then kicks off and validates Alice's change and successfully completes.\n\n   * The change is safe to deploy to the cluster, and the artifacts are saved to the CI pipeline run.\n\n1. The successful CI pipeline run triggers the CD pipeline.\n\n   * The CD pipeline picks up the artifacts stored by Alice's CI pipeline run.\n   * The CD pipeline substitutes the templates with environment-specific values and stages any changes against the existing cluster state in the GitOps repository.\n   * The CD pipeline creates a pull request against the production branch of the GitOps Repo with the desired changes to the cluster state.\n\n1. Alice's team reviews and approves her pull request.\n\n   * The change is merged into the target branch corresponding to the environment.\n\n1. Within minutes, Flux notices a change in the GitOps repository and pulls Alice's change.\n\n   * Because of the Docker image change, the application pod requires an update.\n   * Flux applies the change to the cluster.\n   * Flux reports the deployment status back to the GitOps repository via [GitOps Connector](https://github.com/microsoft/gitops-connector).\n\n1. The CD pipeline runs automated tests to verify the new deployment successfully completed and works as expected.\n\n   > [!NOTE]\n   > For additional environments targeted for deployment, the CD pipeline iterates by creating a pull request for the next environment and repeats steps 4-7. The process many need extra approval for riskier deployments or environments, such as a security-related change or a production environment.\n\n1. When all the environments have received successful deployments, the pipeline completes.",
    "file_path": "/Users/cloudchase/Desktop/Vibe_Coding/Cursor/ai-content-developer/work/tmp/azure-management-docs/articles/azure-arc/kubernetes/conceptual-gitops-flux2-ci-cd.md",
    "heading_path": [
      "CI/CD workflow using GitOps (Flux v2)",
      "Example workflow"
    ],
    "section_level": 2,
    "chunk_index": 11,
    "frontmatter": {
      "title": "CI/CD Workflow using GitOps (Flux v2) - Azure Arc-enabled Kubernetes",
      "description": "This article provides a conceptual overview of a CI/CD workflow using GitOps.",
      "ms.date": "04/22/2025",
      "ms.topic": "concept-article",
      "author": "eedorenko",
      "ms.author": "iefedore"
    },
    "embedding_content": "Document: CI/CD Workflow using GitOps (Flux v2) - Azure Arc-enabled Kubernetes | Topic: concept-article | Description: This article provides a conceptual overview of a CI/CD workflow using GitOps. | Section: CI/CD workflow using GitOps (Flux v2) > Example workflow | ## Example workflow\n\nAs an application developer, Alice:\n\n* Writes application code.\n* Determines how to run the application in a Docker container.\n* Defines the templates that run the container and dependent services in a Kubernetes cluster.\n\nAlice wants to make sure the application has the capability to run in multiple environments, but she doesn't know the specific settings for each environment.\n\nSuppose Alice wants to make an application change that alters the Docker image used in the application deployment template.\n\n1. Alice changes the deployment template, pushes it to a remote branch called `alice` in the Application Repo, and opens a pull request for review against the `main` branch.\n\n1. Alice asks her team to review the change.\n\n   * The PR pipeline runs validation.\n   * After a successful PR pipeline run and team approval, the change is merged.\n\n1. The CI pipeline then kicks off and validates Alice's change and successfully completes.\n\n   * The change is safe to deploy to the cluster, and the artifacts are saved to the CI pipeline run.\n\n1. The successful CI pipeline run triggers the CD pipeline.\n\n   * The CD pipeline picks up the artifacts stored by Alice's CI pipeline run.\n   * The CD pipeline substitutes the templates with environment-specific values and stages any changes against the existing cluster state in the GitOps repository.\n   * The CD pipeline creates a pull request against the production branch of the GitOps Repo with the desired changes to the cluster state.\n\n1. Alice's team reviews and approves her pull request.\n\n   * The change is merged into the target branch corresponding to the environment.\n\n1. Within minutes, Flux notices a change in the GitOps repository and pulls Alice's change.\n\n   * Because of the Docker image change, the application pod requires an update.\n   * Flux applies the change to the cluster.\n   * Flux reports the deployment status back to the GitOps repository via [GitOps Connector](https://github.com/microsoft/gitops-connector).\n\n1. The CD pipeline runs automated tests to verify the new deployment successfully completed and works as expected.\n\n   > [!NOTE]\n   > For additional environments targeted for deployment, the CD pipeline iterates by creating a pull request for the next environment and repeats steps 4-7. The process many need extra approval for riskier deployments or environments, such as a security-related change or a production environment.\n\n1. When all the environments have received successful deployments, the pipeline completes.",
    "embedding": null,
    "embedding_model": null,
    "embedding_generated_at": null,
    "content_hash": "dbf53fd4475d64eb736f1b23d0a0eebc15729d3ab37509e0a276afe6a235c2ff",
    "file_id": "c034872bae0e1b385c7013c870cafa2b3fd327c006d451d059a4fed1eeb95586",
    "chunk_id": "c413e0a5ae4f34d098cd9b24a111ed47e6f329c880a9c5a898f02703658d0ed6",
    "prev_chunk_id": "0c96b1278665164377e19f92d487ba4b6879778d79d797155a77ab69a6055fe7",
    "next_chunk_id": "5258340b9b21cf0e17097e4657ae5b7e0881e0921cf1639fab907ac2a3deb8fc",
    "parent_heading_chunk_id": "e830fa34119f5dba1a26ec1a339a397444ba2cd770e5711b280ec2e898955805",
    "total_chunks_in_file": 13
  },
  "meta": {
    "type": "chunk",
    "file": "/Users/cloudchase/Desktop/Vibe_Coding/Cursor/ai-content-developer/work/tmp/azure-management-docs/articles/azure-arc/kubernetes/conceptual-gitops-flux2-ci-cd.md",
    "section": [
      "CI/CD workflow using GitOps (Flux v2)",
      "Example workflow"
    ],
    "has_embedding": false
  },
  "timestamp": "2025-06-03T19:17:35.956580"
}