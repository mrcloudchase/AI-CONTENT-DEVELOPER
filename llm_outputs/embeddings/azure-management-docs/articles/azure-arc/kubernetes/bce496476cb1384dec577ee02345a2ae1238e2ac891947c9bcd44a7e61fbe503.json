{
  "data": {
    "content": "## High level flow\n\nThis diagram shows how the platform and application team personas interact with each other while performing their regular activities.\n\n:::image type=\"content\" source=\"media/concept-workload-management/high-level-diagram.png\" alt-text=\"Diagram showing how the personas interact with each other.\" lightbox=\"media/concept-workload-management/high-level-diagram.png\":::\n\nThe primary concept of this whole process is separation of concerns. There are workloads, such as applications and platform services, and there is a platform where these workloads run. The application team takes care of the workloads (*what*), while the platform team is focused on the platform (*where*).\n\nThe application team runs SDLC operations on their applications and promotes changes across environments. They don't know which clusters their application is deployed on in each environment. Instead, the application team operates with the concept of *deployment target*, which is simply a named abstraction within an environment. For example, deployment targets could be integration on Dev, functional tests and performance tests on QA, early adopters, external users on Prod, and so on. \n\nThe application team defines deployment targets for each rollout environment, and they know how to configure their application and how to generate manifests for each deployment target. This process is automated and exists in the application repositories space. It results in generated manifests for each deployment target, stored in a manifests storage such as a Git repository, Helm Repository, or OCI storage.\n\nThe platform team has a limited knowledge about the applications, so they aren't involved in the application configuration and deployment process. The platform team is in charge of platform clusters, grouped in cluster types. They describe cluster types with configuration values such as DNS names, endpoints of external services, and so on. The platform team assigns or schedules application deployment targets to various cluster types. With that in place, application behavior on a physical cluster is determined by the combination of the deployment target configuration values, and cluster type configuration values.\n\nThe platform team uses a separate platform repository that contains manifests for each cluster type. These manifests define the workloads that should run on each cluster type, and which platform configuration values should be applied. Clusters can fetch that information from the platform repository with their preferred reconciler and then apply the manifests.\n\nClusters report their compliance state with the platform and application repositories to the Deployment Observability Hub. The platform and application teams can query this information to analyze historical workload deployment across clusters. This information can be used in the dashboards, alerts and in the deployment pipelines to implement progressive rollout.",
    "file_path": "/Users/cloudchase/Desktop/Vibe_Coding/Cursor/ai-content-developer/work/tmp/azure-management-docs/articles/azure-arc/kubernetes/conceptual-workload-management.md",
    "heading_path": [
      "Workload management in a multi-cluster environment with GitOps",
      "High level flow"
    ],
    "section_level": 2,
    "chunk_index": 6,
    "frontmatter": {
      "title": "Workload management in a multi-cluster environment with GitOps",
      "description": "This article provides a conceptual overview of the workload management in a multi-cluster environment with GitOps.",
      "ms.date": "03/29/2023",
      "ms.topic": "concept-article",
      "author": "eedorenko",
      "ms.author": "iefedore"
    },
    "embedding_content": "Document: Workload management in a multi-cluster environment with GitOps | Topic: concept-article | Description: This article provides a conceptual overview of the workload management in a multi-cluster environmen | Section: Workload management in a multi-cluster environment with GitOps > High level flow | ## High level flow\n\nThis diagram shows how the platform and application team personas interact with each other while performing their regular activities.\n\n:::image type=\"content\" source=\"media/concept-workload-management/high-level-diagram.png\" alt-text=\"Diagram showing how the personas interact with each other.\" lightbox=\"media/concept-workload-management/high-level-diagram.png\":::\n\nThe primary concept of this whole process is separation of concerns. There are workloads, such as applications and platform services, and there is a platform where these workloads run. The application team takes care of the workloads (*what*), while the platform team is focused on the platform (*where*).\n\nThe application team runs SDLC operations on their applications and promotes changes across environments. They don't know which clusters their application is deployed on in each environment. Instead, the application team operates with the concept of *deployment target*, which is simply a named abstraction within an environment. For example, deployment targets could be integration on Dev, functional tests and performance tests on QA, early adopters, external users on Prod, and so on. \n\nThe application team defines deployment targets for each rollout environment, and they know how to configure their application and how to generate manifests for each deployment target. This process is automated and exists in the application repositories space. It results in generated manifests for each deployment target, stored in a manifests storage such as a Git repository, Helm Repository, or OCI storage.\n\nThe platform team has a limited knowledge about the applications, so they aren't involved in the application configuration and deployment process. The platform team is in charge of platform clusters, grouped in cluster types. They describe cluster types with configuration values such as DNS names, endpoints of external services, and so on. The platform team assigns or schedules application deployment targets to various cluster types. With that in place, application behavior on a physical cluster is determined by the combination of the deployment target configuration values, and cluster type configuration values.\n\nThe platform team uses a separate platform repository that contains manifests for each cluster type. These manifests define the workloads that should run on each cluster type, and which platform configuration values should be applied. Clusters can fetch that information from the platform repository with their preferred reconciler and then apply the manifests.\n\nClusters report their compliance state with the platform and application repositories to the Deployment Observability Hub. The platform and application teams can query this information to analyze historical workload deployment across clusters. This information can be used in the dashboards, alerts and in the deployment pipelines to implement progressive rollout.",
    "embedding": null,
    "embedding_model": null,
    "embedding_generated_at": null,
    "content_hash": "74f089830eb0c27a43cb5de40d4a791e5656305becd5fb4790740e5b3da3da7b",
    "file_id": "68b84d3ed0d9d36d4ec56ccb018594e09d36629cea891036b7b04a8fba544e6e",
    "chunk_id": "bce496476cb1384dec577ee02345a2ae1238e2ac891947c9bcd44a7e61fbe503",
    "prev_chunk_id": "f3ea88aa6eabdfff12c8eb825d6243c57995d7b3b55b15161efafaf9205b8faa",
    "next_chunk_id": "0387250d256f07197fce49338daace01ec76471a2700417dd969a339cba484f4",
    "parent_heading_chunk_id": "97ea4eec0eba99bbe5f8c55f9a68f9a985be134e19e49f8f6c97ed9781f79187",
    "total_chunks_in_file": 31
  },
  "meta": {
    "type": "chunk",
    "file": "/Users/cloudchase/Desktop/Vibe_Coding/Cursor/ai-content-developer/work/tmp/azure-management-docs/articles/azure-arc/kubernetes/conceptual-workload-management.md",
    "section": [
      "Workload management in a multi-cluster environment with GitOps",
      "High level flow"
    ],
    "has_embedding": false
  },
  "timestamp": "2025-06-03T19:17:33.649603"
}