{
  "data": {
    "content": "### Configuration schema\n\nAlthough the platform team may have limited knowledge about the applications and how they work, they know what platform configuration is required to be present on the target host. This information is provided by the application developers. They specify what configuration values their application needs, their types and constraints. One of the ways to define this contract is to use a JSON schema. For example:\n\n```json\n{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"title\": \"patch-to-core Platform Config Schema\",\n    \"description\": \"Schema for platform config\",\n    \"type\": \"object\",\n    \"properties\": {\n      \"ENVIRONMENT\": {\n      \"type\": \"string\",\n      \"description\": \"Environment Name\"\n      },\n      \"TimeWindowShift\": {\n      \"type\": \"integer\",\n      \"description\": \"Time Window Shift\"\n      },\n      \"QueryIntervalSec\": {\n      \"type\": \"integer\",\n      \"description\": \"Query Interval Sec\"\n      },\n      \"module\": {\n      \"type\": \"object\",\n      \"description\": \"module\",\n      \"properties\": {\n        \"drop-threshold\": { \"type\": \"number\" }\n      },\n      \"required\": [\"drop-threshold\"]      \n      }\n    },\n      \"required\": [\n        \"ENVIRONMENT\",\n        \"module\"\n      ]              \n    }\t    \n```\n\nThis approach is well known in the developer community, as the JSON schema is used by Helm to define the possible values to be provided for a Helm chart. \n\nA formal contract also allows for automation. The platform team uses the control plane to provide the configuration values. The control plane analyzes what applications are supposed to be deployed on a host. It uses configuration schemas to advise what values should be provided by the platform team. The control plane composes configuration values for every application instance and validates them against the schema to see if all the values are in place. \n\nThe control plane may perform validation in multiple stages at different points in time. For example, the control plane validates a configuration value when it is provided by the platform team to check its type, format and basic constrains. The final and the most important validation is conducted when the control plane composes all available configuration values for the application in the configuration snapshot. Only at this point it is possible to check presence of required configuration values and check integrity constraints that involve multiple values, coming from different sources.",
    "file_path": "/Users/cloudchase/Desktop/Vibe_Coding/Cursor/ai-content-developer/work/tmp/azure-management-docs/articles/azure-arc/kubernetes/conceptual-workload-management.md",
    "heading_path": [
      "Workload management in a multi-cluster environment with GitOps",
      "Platform configuration concepts",
      "Configuration schema"
    ],
    "section_level": 3,
    "chunk_index": 18,
    "frontmatter": {
      "title": "Workload management in a multi-cluster environment with GitOps",
      "description": "This article provides a conceptual overview of the workload management in a multi-cluster environment with GitOps.",
      "ms.date": "03/29/2023",
      "ms.topic": "concept-article",
      "author": "eedorenko",
      "ms.author": "iefedore"
    },
    "embedding_content": "Document: Workload management in a multi-cluster environment with GitOps | Topic: concept-article | Description: This article provides a conceptual overview of the workload management in a multi-cluster environmen | Section: Workload management in a multi-cluster environment with GitOps > Platform configuration concepts > Configuration schema | ### Configuration schema\n\nAlthough the platform team may have limited knowledge about the applications and how they work, they know what platform configuration is required to be present on the target host. This information is provided by the application developers. They specify what configuration values their application needs, their types and constraints. One of the ways to define this contract is to use a JSON schema. For example:\n\n```json\n{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"title\": \"patch-to-core Platform Config Schema\",\n    \"description\": \"Schema for platform config\",\n    \"type\": \"object\",\n    \"properties\": {\n      \"ENVIRONMENT\": {\n      \"type\": \"string\",\n      \"description\": \"Environment Name\"\n      },\n      \"TimeWindowShift\": {\n      \"type\": \"integer\",\n      \"description\": \"Time Window Shift\"\n      },\n      \"QueryIntervalSec\": {\n      \"type\": \"integer\",\n      \"description\": \"Query Interval Sec\"\n      },\n      \"module\": {\n      \"type\": \"object\",\n      \"description\": \"module\",\n      \"properties\": {\n        \"drop-threshold\": { \"type\": \"number\" }\n      },\n      \"required\": [\"drop-threshold\"]      \n      }\n    },\n      \"required\": [\n        \"ENVIRONMENT\",\n        \"module\"\n      ]              \n    }\t    \n```\n\nThis approach is well known in the developer community, as the JSON schema is used by Helm to define the possible values to be provided for a Helm chart. \n\nA formal contract also allows for automation. The platform team uses the control plane to provide the configuration values. The control plane analyzes what applications are supposed to be deployed on a host. It uses configuration schemas to advise what values should be provided by the platform team. The control plane composes configuration values for every application instance and validates them against the schema to see if all the values are in place. \n\nThe control plane may perform validation in multiple stages at different points in time. For example, the control plane validates a configuration value when it is provided by the platform team to check its type, format and basic constrains. The final and the most important validation is conducted when the control plane composes all available configuration values for the application in the configuration snapshot. Only at this point it is possible to check presence of required configuration values and check integrity constraints that involve multiple values, coming from different sources.",
    "embedding": null,
    "embedding_model": null,
    "embedding_generated_at": null,
    "content_hash": "e10f3618242b2f2109e140d9ac180e66a209abb9bcb646d59b87fe95da7f5245",
    "file_id": "68b84d3ed0d9d36d4ec56ccb018594e09d36629cea891036b7b04a8fba544e6e",
    "chunk_id": "3cba6ea799c79b0bee78419fe2cb602c2e0609e1c99ddd73902b8b5d81352521",
    "prev_chunk_id": "0afa1230b1a2e56c025596d6260842ee27412c5babf14f20f0e925d9aa7d61d9",
    "next_chunk_id": "6ddb702753e6b52ea072cf47b88bb9c55dff53bbc3ccb57ba168a059d931211d",
    "parent_heading_chunk_id": "4c19057e6a3219c5ce06dac7587993a94ef4dbba041d39c1a6acdb0ae0f2a270",
    "total_chunks_in_file": 31
  },
  "meta": {
    "type": "chunk",
    "file": "/Users/cloudchase/Desktop/Vibe_Coding/Cursor/ai-content-developer/work/tmp/azure-management-docs/articles/azure-arc/kubernetes/conceptual-workload-management.md",
    "section": [
      "Workload management in a multi-cluster environment with GitOps",
      "Platform configuration concepts",
      "Configuration schema"
    ],
    "has_embedding": false
  },
  "timestamp": "2025-06-03T19:17:33.687643"
}